# 15 机制：地址翻译

在CPU虚拟化的发展中，我们专注于一个被称为有限的直接执行（或LDE） 的通用机制。 LDE背后的想法很简单：在大多数情况下，让程序直接在运行硬件；在某个时间的某些关键点（例如，当一个过程发出一个系统调用，或定时器中断发生时）离开它，这样安排可以使操作系统介入并确保“正确”的事情发生了。因而，拥有些许硬件支的持操作系统，会尽最大的离开正在运行的程序，以提供一个高效的虚拟化；然而，通过在时间这些关键点插入，操作系统可确保保持着控制依赖于硬件之上。效率和控制这两点是任何现代操作系统的主要目标。

对于内存虚拟化，我们会采用一个简单的策略，可以保证在提供期望的虚拟化的同时保证效率和控制。效率规定了我们需要使用硬件支持，当然它一开始是比较简陋的（仅仅几个寄存器）但是之后它会变得最够复杂（比如TLBs，页表支持和其他你会看到的）。控制表明操作系统保证了没有程序能够访问除了它拥有的之外的内存，因此，另一方面也是为了保护程序。最后，我们需要获取一些来自VM系统中的，也就是**灵活性**。更准确的是，我们希望程序可以尽情的使用它们的地址空间，从而保证更容易变成。精炼后的关键点。

## 15.1 假设

## 15.2 一个例子

```
void func() {
    int x;
    x = x + 3; // this is the line of code we are interested in
```
```
128: movl 0x0(%ebx), %eax ;load 0+ebx into eax
132: addl $0x03, %eax ;add 3 to eax register
135: movl %eax, 0x0(%ebx) ;store eax back to mem
```

![](/images/15_1.png)

**Figure 15.1: A Process And Its Address Space**

![](/images/15_2.png)

**Figure 15.2: Physical Memory with a Single Relocated Process**


## 15.3 动态重定位（基于硬件）

为了获取对基于硬件的地址转换有的一定了解，我们首先讨论它的第一个化身。1950年代后期推出的第一个分时机器提出的被称为基址和界限一个简单的想法;该技术也被称为动态重定位;我们将同时使用术语互换[SS74]。

具体来说，我们需要每个CPU中的两个硬件寄存器：一种称为基址寄存器，及其它的界限（有时称为限制寄存器）。该基址寄存器和界限寄存器对将要允许我们将地址空间的放置在物理内存中的任何地方，而这样做的同时确保了程序只能访问它自己的地址空间。

在这种设置中，每个程序被写入并且编译就好像它被加载到了地址0。然而，一个程序开始运行，操作系统决定了它会被加载到物理内存的何处同时决定了基址寄存器的值。在上面的例子中，操作系统决定了在物理地址32K字节处加载程序，同时设定基址寄存器为此值。

### Example Translations

| Virtual Address || Physical Address |
| -- | -- | -- |
|0| $$\to$$ | 16KB |
|1KB| $$\to$$ | 17KB  |
|3000| $$\to$$ | 19384  |
|4400| $$\to$$ | Fault(out  |


## 15.4 硬件支持：总结

## 15.5 操作系统问题

## 15.6 总结
